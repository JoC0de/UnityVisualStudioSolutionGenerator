#nullable enable

using System;
using System.Collections.Generic;
using System.IO;

namespace UnityVisualStudioSolutionGenerator
{
    /// <summary>
    ///     Provides methods for parsing Visual Studio solution files (.sln) and extracting referenced project files.
    /// </summary>
    public static class LegacySolutionFileParser
    {
        private const string ProjectStartTagName = "Project";

        private const string ProjectEndTagName = "EndProject";

        /// <summary>
        ///     Parses the solution file and gets the project files referenced from the solution.
        /// </summary>
        /// <param name="content">The solution file content.</param>
        /// <param name="solutionDirectoryPath">The absolute directory path of the solution file.</param>
        /// <param name="onlyIncludeUnityGeneratedProjects">
        ///     Indicates whether to only include project files generated by Unity or files directly inside the solution directory.
        /// </param>
        /// <returns>
        ///     A tuple containing the referenced project files and a flag indicating if the source contains duplicate projects.
        /// </returns>
        public static (IReadOnlyList<ProjectFile> ProjectFiles, bool SourceContainsDuplicateProjects) Parse(
            string content,
            string solutionDirectoryPath,
            bool onlyIncludeUnityGeneratedProjects)
        {
            _ = content ?? throw new ArgumentNullException(nameof(content));
            var projects = GetUsedProjectFiles(content, solutionDirectoryPath);
            return SolutionFileParser.CreateFilteredProjectsResult(solutionDirectoryPath, onlyIncludeUnityGeneratedProjects, projects);
        }

        /// <summary>
        ///     Parses the specified <see cref="SolutionFile" /> and gets the project files referenced from the solution.
        /// </summary>
        /// <param name="solutionFile">The solution file to parse.</param>
        /// <param name="onlyIncludeUnityGeneratedProjects">
        ///     Indicates whether to only include project files generated by Unity or files directly inside the solution directory.
        /// </param>
        /// <returns>
        ///     A tuple containing the referenced project files and a flag indicating if the source contains duplicate projects.
        /// </returns>
        internal static (IReadOnlyList<ProjectFile> ProjectFiles, bool SourceContainsDuplicateProjects) Parse(
            SolutionFile solutionFile,
            bool onlyIncludeUnityGeneratedProjects)
        {
            return Parse(File.ReadAllText(solutionFile.SolutionFilePath), solutionFile.SolutionDirectoryPath, onlyIncludeUnityGeneratedProjects);
        }

        private static IEnumerable<ProjectFile> GetUsedProjectFiles(string content, string solutionDirectoryPath)
        {
            if (!Directory.Exists(solutionDirectoryPath))
            {
                LogHelper.LogError($"Generating a solution file inside a directory that doesn't exists. Directory path: {solutionDirectoryPath}");
            }

            var projectIndex = 0;
            while (projectIndex < content.Length)
            {
                projectIndex = content.IndexOf(ProjectStartTagName, projectIndex, StringComparison.Ordinal);
                if (projectIndex < 0)
                {
                    break;
                }

                projectIndex += ProjectStartTagName.Length;
                projectIndex = SkipWhiteSpaces(content, projectIndex);

                if (content[projectIndex] != '(')
                {
                    // not a project start tag just the word Project
                    continue;
                }

                var endIndex = content.IndexOf(ProjectEndTagName, projectIndex, StringComparison.Ordinal);
                if (endIndex < 0)
                {
                    LogHelper.LogError($"Found 'Project' start but no 'EndProject' starting at char-index: {projectIndex}");
                    continue;
                }

                var firstCommaIndex = content.IndexOf(',', projectIndex, endIndex - projectIndex);
                if (firstCommaIndex < 0)
                {
                    LogHelper.LogError($"Found no ',' inside Project -> EndProject section: {content[projectIndex..endIndex]}");
                    continue;
                }

                ++firstCommaIndex; // skip the comma
                var secondCommaIndex = content.IndexOf(',', firstCommaIndex, endIndex - firstCommaIndex);
                if (secondCommaIndex < 0)
                {
                    LogHelper.LogError($"Found no second ',' inside Project -> EndProject section: {content[projectIndex..endIndex]}");
                    continue;
                }

                var projectFileNamePart = content[firstCommaIndex..secondCommaIndex].Trim('"', ' ');
                if (string.IsNullOrEmpty(projectFileNamePart))
                {
                    LogHelper.LogError($"Failed to extract csproj file name from Project -> EndProject section: {content[projectIndex..endIndex]}");
                    continue;
                }

                ++secondCommaIndex; // skip the comma
                var projectIdEndIndex = content.LastIndexOf('"', endIndex, endIndex - secondCommaIndex);
                if (projectIdEndIndex < 0)
                {
                    LogHelper.LogError(
                        $"Found no ProjectId ('\"') after the second ',' inside Project -> EndProject section: {content[projectIndex..endIndex]}");
                    continue;
                }

                var projectId = content[secondCommaIndex..projectIdEndIndex].Trim('"', ' ');
                projectIndex = endIndex + ProjectEndTagName.Length;

                var projectFilePath = Path.GetFullPath(projectFileNamePart, solutionDirectoryPath);
                yield return new ProjectFile(projectFilePath, projectId);
            }
        }

        private static int SkipWhiteSpaces(string content, int projectIndex)
        {
            while (projectIndex < content.Length && char.IsWhiteSpace(content[projectIndex]))
            {
                ++projectIndex;
            }

            return projectIndex;
        }
    }
}
