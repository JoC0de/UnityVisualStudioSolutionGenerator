#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityVisualStudioSolutionGenerator.Configuration;

namespace UnityVisualStudioSolutionGenerator
{
    /// <summary>
    ///     A post processor that triggers the generation of the updated Visual Studio Solution and Project files.
    ///     It is called by Unity after Unity generated a .csproj file or a .sln file.
    /// </summary>
    internal class VisualStudioAssetPostprocessor : AssetPostprocessor
    {
        /// <summary>
        ///     Called once all .csproj files and the .sln is generated.
        /// </summary>
        /// <remarks>
        ///     Code that calls this: see
        ///     <see href="https://github.com/needle-mirror/com.unity.ide.visualstudio/blob/master/Editor/ProjectGeneration/ProjectGeneration.cs" />.
        /// </remarks>
        private static void OnGeneratedCSProjectFiles()
        {
            if (!GeneratorSettings.IsEnabled)
            {
                return;
            }

            var stopwatch = Stopwatch.StartNew();
            var solutionFile = SolutionFile.CurrentProjectSolution;
            var allProjects = SolutionFileParser.Parse(solutionFile, false);

            var newProjects = GenerateNewProjects(allProjects, solutionFile.SolutionDirectoryPath);

            SolutionFileWriter.WriteToFileSafe(solutionFile.SolutionFilePath, solutionFile.SolutionDirectoryPath, newProjects);
            LogHelper.LogInformation($"Generated Visual Studio Solution: '{solutionFile}' in {stopwatch.ElapsedMilliseconds} ms.");
        }

        private static List<ProjectFile> GenerateNewProjects(IReadOnlyList<ProjectFile> allProjects, string solutionDirectoryPath)
        {
            var newProjects = new List<ProjectFile>();
            foreach (var project in allProjects)
            {
                var generator = ProjectFileGeneratorBase.Create(project.FilePath);

                if (generator.IsProjectFromPackageCache())
                {
                    LogHelper.LogVerbose(
                        $"The project '{Path.GetFileNameWithoutExtension(project.FilePath)}' is a Unity Package so we don't change the '.csproj' file.");
                    newProjects.Add(project);
                    continue;
                }

                var newProjectFilePath = generator.WriteProjectFile(solutionDirectoryPath);

                ReSharperProjectSettingsGenerator.WriteSettingsIfMissing(newProjectFilePath);
                ProjectSourceCodeWatcherManager.AddSourceCodeWatcherForProject(GetDirectoryPath(newProjectFilePath));
                newProjects.Add(new ProjectFile(newProjectFilePath, project.Id));
            }

            return newProjects;
        }

        /// <summary>
        ///     Called after Unity generated a .sln file.
        ///     We need to generate the .sln content here because else the unmodified file is written to the disk -> Visual Studio thinks it need to reload it.
        ///     Also <see cref="OnGeneratedCSProjectFiles" /> is not called for each change.
        /// </summary>
        /// <param name="path">The target path of the generated .sln file.</param>
        /// <param name="content">The content of the .sln file generated by Unity.</param>
        /// <returns>The probably changed content of the .sln file.</returns>
        [SuppressMessage("Design", "CA1031: Do not catch general exception types", Justification = "We keep the input so we have anything.")]
        private static string OnGeneratedSlnSolution(string path, string content)
        {
            try
            {
                if (!GeneratorSettings.IsEnabled)
                {
                    return RemoveGeneratedProjectsFromSolution(path, content);
                }

                var stopwatch = Stopwatch.StartNew();
                var solutionDirectoryPath = GetDirectoryPath(path);
                var allProjects = SolutionFileParser.Parse(content, solutionDirectoryPath, false);
                if (!allProjects.All(project => File.Exists(project.FilePath)))
                {
                    return content;
                }

                var newProjects = GenerateNewProjects(allProjects, solutionDirectoryPath);
                content = SolutionFileWriter.WriteToText(solutionDirectoryPath, newProjects);

                LogHelper.LogInformation(
                    $"Generated content of Visual Studio Solution '{Path.GetFileName(path)}' in {stopwatch.ElapsedMilliseconds} ms.");
                return content;
            }
            catch (Exception e)
            {
                LogHelper.LogWarning(
                    $"Failed to generate solution on '{nameof(OnGeneratedSlnSolution)}' event. Retrying in '{nameof(OnGeneratedCSProjectFiles)}'. Error:\n{e}");
            }

            return content;
        }

        private static string RemoveGeneratedProjectsFromSolution(string path, string content)
        {
            // if one of the .csproj files are inside a folder they are generated from this plugin so we need to remove them
            if (content.IndexOfAny(new[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar }) == -1)
            {
                return content;
            }

            var solutionDirectoryPath = GetDirectoryPath(path);
            var allProjects = SolutionFileParser.Parse(content, solutionDirectoryPath, !GeneratorSettings.IsEnabled);
            return SolutionFileWriter.WriteToText(solutionDirectoryPath, allProjects);
        }

        private static string GetDirectoryPath(string path)
        {
            return Path.GetFullPath(Path.GetDirectoryName(path) ?? throw new InvalidOperationException($"Failed to get directory path of '{path}'"));
        }
    }
}
